{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport React, { useMemo, useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport CircleLayer from \"./CircleLayer\";\nimport RasterLayer from \"./RasterLayer\";\nimport SymbolLayer from \"./SymbolLayer\";\nimport LineLayer from \"./LineLayer\";\nimport FillLayer from \"./FillLayer\";\nimport FillExtrusionLayer from \"./FillExtrusionLayer\";\nimport BackgroundLayer from \"./BackgroundLayer\";\nimport HeatmapLayer from \"./HeatmapLayer\";\nimport VectorSource from \"./VectorSource\";\nimport RasterSource from \"./RasterSource\";\nimport ImageSource from \"./ImageSource\";\nimport ShapeSource from \"./ShapeSource\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\n\nfunction toCamelCase(s) {\n  return s.replace(/([-_][a-z])/gi, function ($1) {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n}\n\nfunction toCamelCaseKeys(oldObj) {\n  if (!oldObj) {\n    return {};\n  }\n\n  var newObj = {};\n  Object.keys(oldObj).forEach(function (key) {\n    var value = oldObj[key];\n\n    if (key.includes('-')) {\n      newObj[toCamelCase(key)] = value;\n    } else {\n      newObj[key] = value;\n    }\n  });\n  return newObj;\n}\n\nfunction getLayerComponentType(layer) {\n  var type = layer.type;\n\n  switch (type) {\n    case 'circle':\n      return CircleLayer;\n\n    case 'symbol':\n      return SymbolLayer;\n\n    case 'raster':\n      return RasterLayer;\n\n    case 'line':\n      return LineLayer;\n\n    case 'fill':\n      return FillLayer;\n\n    case 'fill-extrusion':\n      return FillExtrusionLayer;\n\n    case 'background':\n      return BackgroundLayer;\n\n    case 'heatmap':\n      return HeatmapLayer;\n  }\n\n  console.warn(\"Mapbox layer type '\" + type + \"' is not supported/\");\n  return null;\n}\n\nfunction asLayerComponent(layer) {\n  var LayerComponent = getLayerComponentType(layer);\n\n  if (!LayerComponent) {\n    return null;\n  }\n\n  var style = _objectSpread(_objectSpread({}, toCamelCaseKeys(layer.paint)), toCamelCaseKeys(layer.layout));\n\n  var layerProps = {};\n\n  if (layer.source) {\n    layerProps.sourceID = layer.source;\n  }\n\n  if (layer['source-layer']) {\n    layerProps.sourceLayerID = layer['source-layer'];\n  }\n\n  if (layer.minzoom) {\n    layerProps.minZoomLevel = layer.minzoom;\n  }\n\n  if (layer.maxzoom) {\n    layerProps.maxZoomLevel = layer.maxzoom;\n  }\n\n  if (layer.filter) {\n    layerProps.filter = layer.filter;\n  }\n\n  if (Object.keys(style).length) {\n    layerProps.style = style;\n  }\n\n  return _jsx(LayerComponent, _objectSpread({\n    id: layer.id\n  }, layerProps), layer.id);\n}\n\nfunction getTileSourceProps(source) {\n  var sourceProps = {};\n\n  if (source.url) {\n    sourceProps.url = source.url;\n  }\n\n  if (source.tiles) {\n    sourceProps.tileUrlTemplates = source.tiles;\n  }\n\n  if (source.minzoom !== undefined) {\n    sourceProps.minZoomLevel = source.minzoom;\n  }\n\n  if (source.maxzoom !== undefined) {\n    sourceProps.maxZoomLevel = source.maxzoom;\n  }\n\n  if (source.attribution) {\n    sourceProps.attribution = source.attribution;\n  }\n\n  if (source.scheme && source.scheme === 'tms') {\n    sourceProps.tms = true;\n  }\n\n  return sourceProps;\n}\n\nfunction getVectorSource(id, source) {\n  var sourceProps = _objectSpread({}, getTileSourceProps(source));\n\n  return _jsx(VectorSource, _objectSpread({\n    id: id\n  }, sourceProps), id);\n}\n\nfunction getRasterSource(id, source) {\n  var sourceProps = _objectSpread({}, getTileSourceProps(source));\n\n  if (source.tileSize) {\n    sourceProps.tileSize = source.tileSize;\n  }\n\n  return _jsx(RasterSource, _objectSpread({\n    id: id\n  }, sourceProps), id);\n}\n\nfunction getImageSource(id, source) {\n  var sourceProps = {\n    url: source.url,\n    coordinates: source.coordinates\n  };\n  return _jsx(ImageSource, _objectSpread({\n    id: id\n  }, sourceProps), id);\n}\n\nfunction getShapeSource(id, source) {\n  var sourceProps = {};\n\n  if (source.data && typeof source.data === 'string') {\n    sourceProps.url = source.data;\n  } else if (source.data && typeof source.data === 'object') {\n    sourceProps.shape = source.data;\n  }\n\n  if (source.cluster !== undefined) {\n    sourceProps.cluster = source.cluster;\n  }\n\n  if (source.clusterRadius !== undefined) {\n    sourceProps.clusterRadius = source.clusterRadius;\n  }\n\n  if (source.maxzoom !== undefined) {\n    sourceProps.maxZoomLevel = source.maxzoom;\n  }\n\n  if (source.clusterMaxZoom !== undefined) {\n    sourceProps.clusterMaxZoomLevel = source.clusterMaxZoom;\n  }\n\n  if (source.buffer !== undefined) {\n    sourceProps.buffer = source.buffer;\n  }\n\n  if (source.tolerance !== undefined) {\n    sourceProps.tolerance = source.tolerance;\n  }\n\n  if (source.lineMetrics !== undefined) {\n    sourceProps.lineMetrics = source.lineMetrics;\n  }\n\n  return _jsx(ShapeSource, _objectSpread({\n    id: id\n  }, sourceProps), id);\n}\n\nfunction asSourceComponent(id, source) {\n  switch (source.type) {\n    case 'vector':\n      return getVectorSource(id, source);\n\n    case 'raster':\n      return getRasterSource(id, source);\n\n    case 'image':\n      return getImageSource(id, source);\n\n    case 'geojson':\n      return getShapeSource(id, source);\n  }\n\n  console.warn(\"Mapbox source type '\" + source.type + \"' is not supported/\");\n  return null;\n}\n\nvar Style = function Style(props) {\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      fetchedJson = _useState2[0],\n      setFetchedJson = _useState2[1];\n\n  var json = typeof props.json === 'object' ? props.json : fetchedJson;\n  useEffect(function () {\n    var abortController = new AbortController();\n\n    var fetchStyleJson = function fetchStyleJson() {\n      var response, responseJson;\n      return _regeneratorRuntime.async(function fetchStyleJson$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(fetch(props.json, {\n                signal: abortController.signal\n              }));\n\n            case 3:\n              response = _context.sent;\n              _context.next = 6;\n              return _regeneratorRuntime.awrap(response.json());\n\n            case 6:\n              responseJson = _context.sent;\n              setFetchedJson(responseJson);\n              _context.next = 15;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](0);\n\n              if (!(_context.t0.name === 'AbortError')) {\n                _context.next = 14;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 14:\n              throw _context.t0;\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, [[0, 10]], Promise);\n    };\n\n    if (typeof props.json === 'string') {\n      fetchStyleJson();\n    }\n\n    return function cleanup() {\n      abortController.abort();\n    };\n  }, [props.json]);\n  var layerComponents = useMemo(function () {\n    if (!json.layers) {\n      return [];\n    }\n\n    return json.layers.map(asLayerComponent).filter(function (x) {\n      return !!x;\n    });\n  }, [json.layers]);\n  var sourceComponents = useMemo(function () {\n    if (!json.sources || !Object.keys(json.sources)) {\n      return [];\n    }\n\n    return Object.keys(json.sources).map(function (id) {\n      return asSourceComponent(id, json.sources[id]);\n    }).filter(function (x) {\n      return !!x;\n    });\n  }, [json.sources]);\n  return _jsxs(_Fragment, {\n    children: [sourceComponents, layerComponents]\n  });\n};\n\nStyle.propTypes = {\n  json: PropTypes.any\n};\nexport default Style;","map":{"version":3,"sources":["C:/Users/Adith/sp/node_modules/@react-native-mapbox-gl/maps/javascript/components/Style.js"],"names":["React","useMemo","useState","useEffect","PropTypes","CircleLayer","RasterLayer","SymbolLayer","LineLayer","FillLayer","FillExtrusionLayer","BackgroundLayer","HeatmapLayer","VectorSource","RasterSource","ImageSource","ShapeSource","toCamelCase","s","replace","$1","toUpperCase","toCamelCaseKeys","oldObj","newObj","Object","keys","forEach","key","value","includes","getLayerComponentType","layer","type","console","warn","asLayerComponent","LayerComponent","style","paint","layout","layerProps","source","sourceID","sourceLayerID","minzoom","minZoomLevel","maxzoom","maxZoomLevel","filter","length","id","getTileSourceProps","sourceProps","url","tiles","tileUrlTemplates","undefined","attribution","scheme","tms","getVectorSource","getRasterSource","tileSize","getImageSource","coordinates","getShapeSource","data","shape","cluster","clusterRadius","clusterMaxZoom","clusterMaxZoomLevel","buffer","tolerance","lineMetrics","asSourceComponent","Style","props","fetchedJson","setFetchedJson","json","abortController","AbortController","fetchStyleJson","fetch","signal","response","responseJson","name","cleanup","abort","layerComponents","layers","map","x","sourceComponents","sources","propTypes","any"],"mappings":"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","sourcesContent":["import React, {useMemo, useState, useEffect} from 'react';\nimport PropTypes from 'prop-types';\n\nimport CircleLayer from './CircleLayer';\nimport RasterLayer from './RasterLayer';\nimport SymbolLayer from './SymbolLayer';\nimport LineLayer from './LineLayer';\nimport FillLayer from './FillLayer';\nimport FillExtrusionLayer from './FillExtrusionLayer';\nimport BackgroundLayer from './BackgroundLayer';\nimport HeatmapLayer from './HeatmapLayer';\nimport VectorSource from './VectorSource';\nimport RasterSource from './RasterSource';\nimport ImageSource from './ImageSource';\nimport ShapeSource from './ShapeSource';\n\nfunction toCamelCase(s) {\n  return s.replace(/([-_][a-z])/gi, $1 => {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n}\n\n// Patches the Mapbox Style Specification keys into the style props attributes:\n// icon-allow-overlap -> iconAllowOverlap\nfunction toCamelCaseKeys(oldObj) {\n  if (!oldObj) {\n    return {};\n  }\n  const newObj = {};\n  Object.keys(oldObj).forEach(key => {\n    const value = oldObj[key];\n    if (key.includes('-')) {\n      newObj[toCamelCase(key)] = value;\n    } else {\n      newObj[key] = value;\n    }\n  });\n  return newObj;\n}\n\nfunction getLayerComponentType(layer) {\n  const {type} = layer;\n\n  switch (type) {\n    case 'circle':\n      return CircleLayer;\n    case 'symbol':\n      return SymbolLayer;\n    case 'raster':\n      return RasterLayer;\n    case 'line':\n      return LineLayer;\n    case 'fill':\n      return FillLayer;\n    case 'fill-extrusion':\n      return FillExtrusionLayer;\n    case 'background':\n      return BackgroundLayer;\n    case 'heatmap':\n      return HeatmapLayer;\n  }\n\n  console.warn(`Mapbox layer type '${type}' is not supported/`);\n\n  return null;\n}\n\nfunction asLayerComponent(layer) {\n  const LayerComponent = getLayerComponentType(layer);\n  if (!LayerComponent) {\n    return null;\n  }\n\n  const style = {\n    ...toCamelCaseKeys(layer.paint),\n    ...toCamelCaseKeys(layer.layout),\n  };\n\n  const layerProps = {};\n\n  if (layer.source) {\n    layerProps.sourceID = layer.source;\n  }\n  if (layer['source-layer']) {\n    layerProps.sourceLayerID = layer['source-layer'];\n  }\n  if (layer.minzoom) {\n    layerProps.minZoomLevel = layer.minzoom;\n  }\n  if (layer.maxzoom) {\n    layerProps.maxZoomLevel = layer.maxzoom;\n  }\n  if (layer.filter) {\n    layerProps.filter = layer.filter;\n  }\n  if (Object.keys(style).length) {\n    layerProps.style = style;\n  }\n\n  return <LayerComponent key={layer.id} id={layer.id} {...layerProps} />;\n}\n\nfunction getTileSourceProps(source) {\n  const sourceProps = {};\n  if (source.url) {\n    sourceProps.url = source.url;\n  }\n  if (source.tiles) {\n    sourceProps.tileUrlTemplates = source.tiles;\n  }\n  if (source.minzoom !== undefined) {\n    sourceProps.minZoomLevel = source.minzoom;\n  }\n  if (source.maxzoom !== undefined) {\n    sourceProps.maxZoomLevel = source.maxzoom;\n  }\n  if (source.attribution) {\n    sourceProps.attribution = source.attribution;\n  }\n  if (source.scheme && source.scheme === 'tms') {\n    sourceProps.tms = true;\n  }\n  return sourceProps;\n}\n\nfunction getVectorSource(id, source) {\n  const sourceProps = {...getTileSourceProps(source)};\n  return <VectorSource key={id} id={id} {...sourceProps} />;\n}\n\nfunction getRasterSource(id, source) {\n  const sourceProps = {...getTileSourceProps(source)};\n  if (source.tileSize) {\n    sourceProps.tileSize = source.tileSize;\n  }\n  return <RasterSource key={id} id={id} {...sourceProps} />;\n}\n\nfunction getImageSource(id, source) {\n  const sourceProps = {\n    url: source.url,\n    coordinates: source.coordinates,\n  };\n  return <ImageSource key={id} id={id} {...sourceProps} />;\n}\n\nfunction getShapeSource(id, source) {\n  const sourceProps = {};\n  if (source.data && typeof source.data === 'string') {\n    sourceProps.url = source.data;\n  } else if (source.data && typeof source.data === 'object') {\n    sourceProps.shape = source.data;\n  }\n  if (source.cluster !== undefined) {\n    sourceProps.cluster = source.cluster;\n  }\n  if (source.clusterRadius !== undefined) {\n    sourceProps.clusterRadius = source.clusterRadius;\n  }\n  if (source.maxzoom !== undefined) {\n    sourceProps.maxZoomLevel = source.maxzoom;\n  }\n  if (source.clusterMaxZoom !== undefined) {\n    sourceProps.clusterMaxZoomLevel = source.clusterMaxZoom;\n  }\n  if (source.buffer !== undefined) {\n    sourceProps.buffer = source.buffer;\n  }\n  if (source.tolerance !== undefined) {\n    sourceProps.tolerance = source.tolerance;\n  }\n  if (source.lineMetrics !== undefined) {\n    sourceProps.lineMetrics = source.lineMetrics;\n  }\n  return <ShapeSource key={id} id={id} {...sourceProps} />;\n}\n\nfunction asSourceComponent(id, source) {\n  switch (source.type) {\n    case 'vector':\n      return getVectorSource(id, source);\n    case 'raster':\n      return getRasterSource(id, source);\n    case 'image':\n      return getImageSource(id, source);\n    case 'geojson':\n      return getShapeSource(id, source);\n  }\n\n  console.warn(`Mapbox source type '${source.type}' is not supported/`);\n\n  return null;\n}\n\n/**\n * Style is a component that automatically adds sources / layers to the map using Mapbox GL Style Spec.\n * Only [`sources`](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources) & [`layers`](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/) are supported.\n * Other fields such as `sprites`, `glyphs` etc. will be ignored. Not all layer / source attributes from the style spec are supported, in general the supported attributes will mentioned under https://github.com/rnmapbox/maps/tree/master/docs.\n */\nconst Style = props => {\n  const [fetchedJson, setFetchedJson] = useState({});\n  const json = typeof props.json === 'object' ? props.json : fetchedJson;\n\n  // Fetch style when props.json is a URL\n  useEffect(() => {\n    const abortController = new AbortController();\n    const fetchStyleJson = async () => {\n      try {\n        const response = await fetch(props.json, {\n          signal: abortController.signal,\n        });\n        const responseJson = await response.json();\n        setFetchedJson(responseJson);\n      } catch (e) {\n        if (e.name === 'AbortError') {\n          return;\n        }\n        throw e;\n      }\n    };\n    if (typeof props.json === 'string') {\n      fetchStyleJson();\n    }\n    return function cleanup() {\n      abortController.abort();\n    };\n  }, [props.json]);\n\n  // Extract layer components from json\n  const layerComponents = useMemo(() => {\n    if (!json.layers) {\n      return [];\n    }\n    return json.layers.map(asLayerComponent).filter(x => !!x);\n  }, [json.layers]);\n\n  // Extract source components from json\n  const sourceComponents = useMemo(() => {\n    if (!json.sources || !Object.keys(json.sources)) {\n      return [];\n    }\n    return Object.keys(json.sources)\n      .map(id => asSourceComponent(id, json.sources[id]))\n      .filter(x => !!x);\n  }, [json.sources]);\n\n  return (\n    <>\n      {sourceComponents}\n      {layerComponents}\n    </>\n  );\n};\n\nStyle.propTypes = {\n  /**\n   * A JSON object conforming to the schema described in the Mapbox Style Specification , or a URL to such JSON.\n   */\n  json: PropTypes.any,\n};\n\nexport default Style;\n"]},"metadata":{},"sourceType":"module"}