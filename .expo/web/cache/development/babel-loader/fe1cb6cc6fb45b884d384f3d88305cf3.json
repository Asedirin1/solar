{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport NativeEventEmitter from \"react-native-web/dist/exports/NativeEventEmitter\";\nimport { isUndefined, isFunction, isAndroid } from \"../../utils\";\nimport OfflineCreatePackOptions from \"./OfflineCreatePackOptions\";\nimport OfflinePack from \"./OfflinePack\";\nvar MapboxGL = NativeModules.MGLModule;\nvar MapboxGLOfflineManager = NativeModules.MGLOfflineModule;\nexport var OfflineModuleEventEmitter = new NativeEventEmitter(MapboxGLOfflineManager);\n\nvar OfflineManager = function () {\n  function OfflineManager() {\n    _classCallCheck(this, OfflineManager);\n\n    this._hasInitialized = false;\n    this._offlinePacks = {};\n    this._progressListeners = {};\n    this._errorListeners = {};\n    this._onProgress = this._onProgress.bind(this);\n    this._onError = this._onError.bind(this);\n    this.subscriptionProgress = null;\n    this.subscriptionError = null;\n  }\n\n  _createClass(OfflineManager, [{\n    key: \"createPack\",\n    value: function createPack(options, progressListener, errorListener) {\n      var packOptions, nativeOfflinePack;\n      return _regeneratorRuntime.async(function createPack$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 2:\n              packOptions = new OfflineCreatePackOptions(options);\n\n              if (!this._offlinePacks[packOptions.name]) {\n                _context.next = 5;\n                break;\n              }\n\n              throw new Error(\"Offline pack with name \" + packOptions.name + \" already exists.\");\n\n            case 5:\n              this.subscribe(packOptions.name, progressListener, errorListener);\n              _context.next = 8;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.createPack(packOptions));\n\n            case 8:\n              nativeOfflinePack = _context.sent;\n              this._offlinePacks[packOptions.name] = new OfflinePack(nativeOfflinePack);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"invalidatePack\",\n    value: function invalidatePack(name) {\n      var offlinePack;\n      return _regeneratorRuntime.async(function invalidatePack$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (name) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              _context2.next = 4;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 4:\n              offlinePack = this._offlinePacks[name];\n\n              if (!offlinePack) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 8;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.invalidatePack(name));\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"deletePack\",\n    value: function deletePack(name) {\n      var offlinePack;\n      return _regeneratorRuntime.async(function deletePack$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (name) {\n                _context3.next = 2;\n                break;\n              }\n\n              return _context3.abrupt(\"return\");\n\n            case 2:\n              _context3.next = 4;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 4:\n              offlinePack = this._offlinePacks[name];\n\n              if (!offlinePack) {\n                _context3.next = 9;\n                break;\n              }\n\n              _context3.next = 8;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.deletePack(name));\n\n            case 8:\n              delete this._offlinePacks[name];\n\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"invalidateAmbientCache\",\n    value: function invalidateAmbientCache() {\n      return _regeneratorRuntime.async(function invalidateAmbientCache$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 2:\n              _context4.next = 4;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.invalidateAmbientCache());\n\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"clearAmbientCache\",\n    value: function clearAmbientCache() {\n      return _regeneratorRuntime.async(function clearAmbientCache$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 2:\n              _context5.next = 4;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.clearAmbientCache());\n\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setMaximumAmbientCacheSize\",\n    value: function setMaximumAmbientCacheSize(size) {\n      return _regeneratorRuntime.async(function setMaximumAmbientCacheSize$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 2:\n              _context6.next = 4;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.setMaximumAmbientCacheSize(size));\n\n            case 4:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"resetDatabase\",\n    value: function resetDatabase() {\n      return _regeneratorRuntime.async(function resetDatabase$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 2:\n              _context7.next = 4;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.resetDatabase());\n\n            case 4:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getPacks\",\n    value: function getPacks() {\n      var _this = this;\n\n      return _regeneratorRuntime.async(function getPacks$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 2:\n              return _context8.abrupt(\"return\", Object.keys(this._offlinePacks).map(function (name) {\n                return _this._offlinePacks[name];\n              }));\n\n            case 3:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getPack\",\n    value: function getPack(name) {\n      return _regeneratorRuntime.async(function getPack$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 2:\n              return _context9.abrupt(\"return\", this._offlinePacks[name]);\n\n            case 3:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"mergeOfflineRegions\",\n    value: function mergeOfflineRegions(path) {\n      return _regeneratorRuntime.async(function mergeOfflineRegions$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return _regeneratorRuntime.awrap(this._initialize());\n\n            case 2:\n              return _context10.abrupt(\"return\", MapboxGLOfflineManager.mergeOfflineRegions(path));\n\n            case 3:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setTileCountLimit\",\n    value: function setTileCountLimit(limit) {\n      MapboxGLOfflineManager.setTileCountLimit(limit);\n    }\n  }, {\n    key: \"setProgressEventThrottle\",\n    value: function setProgressEventThrottle(throttleValue) {\n      MapboxGLOfflineManager.setProgressEventThrottle(throttleValue);\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(packName, progressListener, errorListener) {\n      var totalProgressListeners, totalErrorListeners;\n      return _regeneratorRuntime.async(function subscribe$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              totalProgressListeners = Object.keys(this._progressListeners).length;\n\n              if (isFunction(progressListener)) {\n                if (totalProgressListeners === 0) {\n                  this.subscriptionProgress = OfflineModuleEventEmitter.addListener(MapboxGL.OfflineCallbackName.Progress, this._onProgress);\n                }\n\n                this._progressListeners[packName] = progressListener;\n              }\n\n              totalErrorListeners = Object.keys(this._errorListeners).length;\n\n              if (isFunction(errorListener)) {\n                if (totalErrorListeners === 0) {\n                  this.subscriptionError = OfflineModuleEventEmitter.addListener(MapboxGL.OfflineCallbackName.Error, this._onError);\n                }\n\n                this._errorListeners[packName] = errorListener;\n              }\n\n              if (!(isAndroid() && this._offlinePacks[packName])) {\n                _context11.next = 13;\n                break;\n              }\n\n              _context11.prev = 5;\n              _context11.next = 8;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.setPackObserver(packName));\n\n            case 8:\n              _context11.next = 13;\n              break;\n\n            case 10:\n              _context11.prev = 10;\n              _context11.t0 = _context11[\"catch\"](5);\n              console.log('Unable to set pack observer', _context11.t0);\n\n            case 13:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, this, [[5, 10]], Promise);\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(packName) {\n      delete this._progressListeners[packName];\n      delete this._errorListeners[packName];\n\n      if (Object.keys(this._progressListeners).length === 0 && this.subscriptionProgress) {\n        this.subscriptionProgress.remove();\n      }\n\n      if (Object.keys(this._errorListeners).length === 0 && this.subscriptionError) {\n        this.subscriptionError.remove();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var nativeOfflinePacks, _iterator, _step, nativeOfflinePack, offlinePack;\n\n      return _regeneratorRuntime.async(function _initialize$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!this._hasInitialized) {\n                _context12.next = 2;\n                break;\n              }\n\n              return _context12.abrupt(\"return\", true);\n\n            case 2:\n              _context12.next = 4;\n              return _regeneratorRuntime.awrap(MapboxGLOfflineManager.getPacks());\n\n            case 4:\n              nativeOfflinePacks = _context12.sent;\n\n              for (_iterator = _createForOfIteratorHelperLoose(nativeOfflinePacks); !(_step = _iterator()).done;) {\n                nativeOfflinePack = _step.value;\n                offlinePack = new OfflinePack(nativeOfflinePack);\n                this._offlinePacks[offlinePack.name] = offlinePack;\n              }\n\n              this._hasInitialized = true;\n              return _context12.abrupt(\"return\", true);\n\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(e) {\n      var _e$payload = e.payload,\n          name = _e$payload.name,\n          state = _e$payload.state;\n\n      if (!this._hasListeners(name, this._progressListeners)) {\n        return;\n      }\n\n      var pack = this._offlinePacks[name];\n\n      this._progressListeners[name](pack, e.payload);\n\n      if (state === MapboxGL.OfflinePackDownloadState.Complete) {\n        this.unsubscribe(name);\n      }\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(e) {\n      var name = e.payload.name;\n\n      if (!this._hasListeners(name, this._errorListeners)) {\n        return;\n      }\n\n      var pack = this._offlinePacks[name];\n\n      this._errorListeners[name](pack, e.payload);\n    }\n  }, {\n    key: \"_hasListeners\",\n    value: function _hasListeners(name, listenerMap) {\n      return !isUndefined(this._offlinePacks[name]) && isFunction(listenerMap[name]);\n    }\n  }]);\n\n  return OfflineManager;\n}();\n\nvar offlineManager = new OfflineManager();\nexport default offlineManager;","map":{"version":3,"sources":["C:/Users/Adith/sp/node_modules/@react-native-mapbox-gl/maps/javascript/modules/offline/offlineManager.js"],"names":["isUndefined","isFunction","isAndroid","OfflineCreatePackOptions","OfflinePack","MapboxGL","NativeModules","MGLModule","MapboxGLOfflineManager","MGLOfflineModule","OfflineModuleEventEmitter","NativeEventEmitter","OfflineManager","_hasInitialized","_offlinePacks","_progressListeners","_errorListeners","_onProgress","bind","_onError","subscriptionProgress","subscriptionError","options","progressListener","errorListener","_initialize","packOptions","name","Error","subscribe","createPack","nativeOfflinePack","offlinePack","invalidatePack","deletePack","invalidateAmbientCache","clearAmbientCache","size","setMaximumAmbientCacheSize","resetDatabase","Object","keys","map","path","mergeOfflineRegions","limit","setTileCountLimit","throttleValue","setProgressEventThrottle","packName","totalProgressListeners","length","addListener","OfflineCallbackName","Progress","totalErrorListeners","setPackObserver","console","log","remove","getPacks","nativeOfflinePacks","e","payload","state","_hasListeners","pack","OfflinePackDownloadState","Complete","unsubscribe","listenerMap","offlineManager"],"mappings":";;;;;;;;;;;;AAEA,SAAQA,WAAR,EAAqBC,UAArB,EAAiCC,SAAjC;AAEA,OAAOC,wBAAP;AACA,OAAOC,WAAP;AAEA,IAAMC,QAAQ,GAAGC,aAAa,CAACC,SAA/B;AACA,IAAMC,sBAAsB,GAAGF,aAAa,CAACG,gBAA7C;AACA,OAAO,IAAMC,yBAAyB,GAAG,IAAIC,kBAAJ,CACvCH,sBADuC,CAAlC;;IASDI,c;AACJ,4BAAc;AAAA;;AACZ,SAAKC,eAAL,GAAuB,KAAvB;AACA,SAAKC,aAAL,GAAqB,EAArB;AAEA,SAAKC,kBAAL,GAA0B,EAA1B;AACA,SAAKC,eAAL,GAAuB,EAAvB;AAEA,SAAKC,WAAL,GAAmB,KAAKA,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAnB;AACA,SAAKC,QAAL,GAAgB,KAAKA,QAAL,CAAcD,IAAd,CAAmB,IAAnB,CAAhB;AAEA,SAAKE,oBAAL,GAA4B,IAA5B;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACD;;;;WAuBD,oBAAiBC,OAAjB,EAA0BC,gBAA1B,EAA4CC,aAA5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+CACQ,KAAKC,WAAL,EADR;;AAAA;AAGQC,cAAAA,WAHR,GAGsB,IAAIvB,wBAAJ,CAA6BmB,OAA7B,CAHtB;;AAAA,mBAKM,KAAKR,aAAL,CAAmBY,WAAW,CAACC,IAA/B,CALN;AAAA;AAAA;AAAA;;AAAA,oBAMU,IAAIC,KAAJ,6BACsBF,WAAW,CAACC,IADlC,sBANV;;AAAA;AAWE,mBAAKE,SAAL,CAAeH,WAAW,CAACC,IAA3B,EAAiCJ,gBAAjC,EAAmDC,aAAnD;AAXF;AAAA,+CAYkChB,sBAAsB,CAACsB,UAAvB,CAC9BJ,WAD8B,CAZlC;;AAAA;AAYQK,cAAAA,iBAZR;AAeE,mBAAKjB,aAAL,CAAmBY,WAAW,CAACC,IAA/B,IAAuC,IAAIvB,WAAJ,CAAgB2B,iBAAhB,CAAvC;;AAfF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WA6BA,wBAAqBJ,IAArB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACOA,IADP;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,+CAKQ,KAAKF,WAAL,EALR;;AAAA;AAOQO,cAAAA,WAPR,GAOsB,KAAKlB,aAAL,CAAmBa,IAAnB,CAPtB;;AAAA,mBAQMK,WARN;AAAA;AAAA;AAAA;;AAAA;AAAA,+CASUxB,sBAAsB,CAACyB,cAAvB,CAAsCN,IAAtC,CATV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAsBA,oBAAiBA,IAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACOA,IADP;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,+CAKQ,KAAKF,WAAL,EALR;;AAAA;AAOQO,cAAAA,WAPR,GAOsB,KAAKlB,aAAL,CAAmBa,IAAnB,CAPtB;;AAAA,mBAQMK,WARN;AAAA;AAAA;AAAA;;AAAA;AAAA,+CASUxB,sBAAsB,CAAC0B,UAAvB,CAAkCP,IAAlC,CATV;;AAAA;AAUI,qBAAO,KAAKb,aAAL,CAAmBa,IAAnB,CAAP;;AAVJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+CACQ,KAAKF,WAAL,EADR;;AAAA;AAAA;AAAA,+CAEQjB,sBAAsB,CAAC2B,sBAAvB,EAFR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+CACQ,KAAKV,WAAL,EADR;;AAAA;AAAA;AAAA,+CAEQjB,sBAAsB,CAAC4B,iBAAvB,EAFR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAeA,oCAAiCC,IAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+CACQ,KAAKZ,WAAL,EADR;;AAAA;AAAA;AAAA,+CAEQjB,sBAAsB,CAAC8B,0BAAvB,CAAkDD,IAAlD,CAFR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+CACQ,KAAKZ,WAAL,EADR;;AAAA;AAAA;AAAA,+CAEQjB,sBAAsB,CAAC+B,aAAvB,EAFR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAaA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+CACQ,KAAKd,WAAL,EADR;;AAAA;AAAA,gDAESe,MAAM,CAACC,IAAP,CAAY,KAAK3B,aAAjB,EAAgC4B,GAAhC,CACL,UAAAf,IAAI;AAAA,uBAAI,KAAI,CAACb,aAAL,CAAmBa,IAAnB,CAAJ;AAAA,eADC,CAFT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAgBA,iBAAcA,IAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+CACQ,KAAKF,WAAL,EADR;;AAAA;AAAA,gDAES,KAAKX,aAAL,CAAmBa,IAAnB,CAFT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAcA,6BAA0BgB,IAA1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+CACQ,KAAKlB,WAAL,EADR;;AAAA;AAAA,iDAESjB,sBAAsB,CAACoC,mBAAvB,CAA2CD,IAA3C,CAFT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAeA,2BAAkBE,KAAlB,EAAyB;AACvBrC,MAAAA,sBAAsB,CAACsC,iBAAvB,CAAyCD,KAAzC;AACD;;;WAYD,kCAAyBE,aAAzB,EAAwC;AACtCvC,MAAAA,sBAAsB,CAACwC,wBAAvB,CAAgDD,aAAhD;AACD;;;WAgBD,mBAAgBE,QAAhB,EAA0B1B,gBAA1B,EAA4CC,aAA5C;AAAA;AAAA;AAAA;AAAA;AAAA;AACQ0B,cAAAA,sBADR,GACiCV,MAAM,CAACC,IAAP,CAAY,KAAK1B,kBAAjB,EAAqCoC,MADtE;;AAEE,kBAAIlD,UAAU,CAACsB,gBAAD,CAAd,EAAkC;AAChC,oBAAI2B,sBAAsB,KAAK,CAA/B,EAAkC;AAChC,uBAAK9B,oBAAL,GAA4BV,yBAAyB,CAAC0C,WAA1B,CAC1B/C,QAAQ,CAACgD,mBAAT,CAA6BC,QADH,EAE1B,KAAKrC,WAFqB,CAA5B;AAID;;AACD,qBAAKF,kBAAL,CAAwBkC,QAAxB,IAAoC1B,gBAApC;AACD;;AAEKgC,cAAAA,mBAZR,GAY8Bf,MAAM,CAACC,IAAP,CAAY,KAAKzB,eAAjB,EAAkCmC,MAZhE;;AAaE,kBAAIlD,UAAU,CAACuB,aAAD,CAAd,EAA+B;AAC7B,oBAAI+B,mBAAmB,KAAK,CAA5B,EAA+B;AAC7B,uBAAKlC,iBAAL,GAAyBX,yBAAyB,CAAC0C,WAA1B,CACvB/C,QAAQ,CAACgD,mBAAT,CAA6BzB,KADN,EAEvB,KAAKT,QAFkB,CAAzB;AAID;;AACD,qBAAKH,eAAL,CAAqBiC,QAArB,IAAiCzB,aAAjC;AACD;;AArBH,oBAyBMtB,SAAS,MAAM,KAAKY,aAAL,CAAmBmC,QAAnB,CAzBrB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,+CA4BYzC,sBAAsB,CAACgD,eAAvB,CAAuCP,QAAvC,CA5BZ;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AA8BMQ,cAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ;;AA9BN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WA6CA,qBAAYT,QAAZ,EAAsB;AACpB,aAAO,KAAKlC,kBAAL,CAAwBkC,QAAxB,CAAP;AACA,aAAO,KAAKjC,eAAL,CAAqBiC,QAArB,CAAP;;AAEA,UACET,MAAM,CAACC,IAAP,CAAY,KAAK1B,kBAAjB,EAAqCoC,MAArC,KAAgD,CAAhD,IACA,KAAK/B,oBAFP,EAGE;AACA,aAAKA,oBAAL,CAA0BuC,MAA1B;AACD;;AAED,UACEnB,MAAM,CAACC,IAAP,CAAY,KAAKzB,eAAjB,EAAkCmC,MAAlC,KAA6C,CAA7C,IACA,KAAK9B,iBAFP,EAGE;AACA,aAAKA,iBAAL,CAAuBsC,MAAvB;AACD;AACF;;;WAED;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,mBACM,KAAK9C,eADX;AAAA;AAAA;AAAA;;AAAA,iDAEW,IAFX;;AAAA;AAAA;AAAA,+CAKmCL,sBAAsB,CAACoD,QAAvB,EALnC;;AAAA;AAKQC,cAAAA,kBALR;;AAOE,+DAAgCA,kBAAhC,iCAAoD;AAAzC9B,gBAAAA,iBAAyC;AAC5CC,gBAAAA,WAD4C,GAC9B,IAAI5B,WAAJ,CAAgB2B,iBAAhB,CAD8B;AAElD,qBAAKjB,aAAL,CAAmBkB,WAAW,CAACL,IAA/B,IAAuCK,WAAvC;AACD;;AAED,mBAAKnB,eAAL,GAAuB,IAAvB;AAZF,iDAaS,IAbT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAgBA,qBAAYiD,CAAZ,EAAe;AACb,uBAAsBA,CAAC,CAACC,OAAxB;AAAA,UAAOpC,IAAP,cAAOA,IAAP;AAAA,UAAaqC,KAAb,cAAaA,KAAb;;AAEA,UAAI,CAAC,KAAKC,aAAL,CAAmBtC,IAAnB,EAAyB,KAAKZ,kBAA9B,CAAL,EAAwD;AACtD;AACD;;AAED,UAAMmD,IAAI,GAAG,KAAKpD,aAAL,CAAmBa,IAAnB,CAAb;;AACA,WAAKZ,kBAAL,CAAwBY,IAAxB,EAA8BuC,IAA9B,EAAoCJ,CAAC,CAACC,OAAtC;;AAGA,UAAIC,KAAK,KAAK3D,QAAQ,CAAC8D,wBAAT,CAAkCC,QAAhD,EAA0D;AACxD,aAAKC,WAAL,CAAiB1C,IAAjB;AACD;AACF;;;WAED,kBAASmC,CAAT,EAAY;AACV,UAAOnC,IAAP,GAAemC,CAAC,CAACC,OAAjB,CAAOpC,IAAP;;AAEA,UAAI,CAAC,KAAKsC,aAAL,CAAmBtC,IAAnB,EAAyB,KAAKX,eAA9B,CAAL,EAAqD;AACnD;AACD;;AAED,UAAMkD,IAAI,GAAG,KAAKpD,aAAL,CAAmBa,IAAnB,CAAb;;AACA,WAAKX,eAAL,CAAqBW,IAArB,EAA2BuC,IAA3B,EAAiCJ,CAAC,CAACC,OAAnC;AACD;;;WAED,uBAAcpC,IAAd,EAAoB2C,WAApB,EAAiC;AAC/B,aACE,CAACtE,WAAW,CAAC,KAAKc,aAAL,CAAmBa,IAAnB,CAAD,CAAZ,IAA0C1B,UAAU,CAACqE,WAAW,CAAC3C,IAAD,CAAZ,CADtD;AAGD;;;;;;AAGH,IAAM4C,cAAc,GAAG,IAAI3D,cAAJ,EAAvB;AACA,eAAe2D,cAAf","sourcesContent":["import {NativeModules, NativeEventEmitter} from 'react-native';\n\nimport {isUndefined, isFunction, isAndroid} from '../../utils';\n\nimport OfflineCreatePackOptions from './OfflineCreatePackOptions';\nimport OfflinePack from './OfflinePack';\n\nconst MapboxGL = NativeModules.MGLModule;\nconst MapboxGLOfflineManager = NativeModules.MGLOfflineModule;\nexport const OfflineModuleEventEmitter = new NativeEventEmitter(\n  MapboxGLOfflineManager,\n);\n\n/**\n * OfflineManager implements a singleton (shared object) that manages offline packs.\n * All of this classâ€™s instance methods are asynchronous, reflecting the fact that offline resources are stored in a database.\n * The shared object maintains a canonical collection of offline packs.\n */\nclass OfflineManager {\n  constructor() {\n    this._hasInitialized = false;\n    this._offlinePacks = {};\n\n    this._progressListeners = {};\n    this._errorListeners = {};\n\n    this._onProgress = this._onProgress.bind(this);\n    this._onError = this._onError.bind(this);\n\n    this.subscriptionProgress = null;\n    this.subscriptionError = null;\n  }\n\n  /**\n   * Creates and registers an offline pack that downloads the resources needed to use the given region offline.\n   *\n   * @example\n   *\n   * const progressListener = (offlineRegion, status) => console.log(offlineRegion, status);\n   * const errorListener = (offlineRegion, err) => console.log(offlineRegion, err);\n   *\n   * await MapboxGL.offlineManager.createPack({\n   *   name: 'offlinePack',\n   *   styleURL: 'mapbox://...',\n   *   minZoom: 14,\n   *   maxZoom: 20,\n   *   bounds: [[neLng, neLat], [swLng, swLat]]\n   * }, progressListener, errorListener)\n   *\n   * @param  {OfflineCreatePackOptions} options Create options for a offline pack that specifices zoom levels, style url, and the region to download.\n   * @param  {Callback=} progressListener Callback that listens for status events while downloading the offline resource.\n   * @param  {Callback=} errorListener Callback that listens for status events while downloading the offline resource.\n   * @return {void}\n   */\n  async createPack(options, progressListener, errorListener) {\n    await this._initialize();\n\n    const packOptions = new OfflineCreatePackOptions(options);\n\n    if (this._offlinePacks[packOptions.name]) {\n      throw new Error(\n        `Offline pack with name ${packOptions.name} already exists.`,\n      );\n    }\n\n    this.subscribe(packOptions.name, progressListener, errorListener);\n    const nativeOfflinePack = await MapboxGLOfflineManager.createPack(\n      packOptions,\n    );\n    this._offlinePacks[packOptions.name] = new OfflinePack(nativeOfflinePack);\n  }\n\n  /**\n   * Invalidates the specified offline pack. This method checks that the tiles in the specified offline pack match those from the server. Local tiles that do not match the latest version on the server are updated.\n   *\n   * This is more efficient than deleting the offline pack and downloading it again. If the data stored locally matches that on the server, new data will not be downloaded.\n   *\n   * @example\n   * await MapboxGL.offlineManager.invalidatePack('packName')\n   *\n   * @param  {String}  name  Name of the offline pack.\n   * @return {void}\n   */\n  async invalidatePack(name) {\n    if (!name) {\n      return;\n    }\n\n    await this._initialize();\n\n    const offlinePack = this._offlinePacks[name];\n    if (offlinePack) {\n      await MapboxGLOfflineManager.invalidatePack(name);\n    }\n  }\n\n  /**\n   * Unregisters the given offline pack and allows resources that are no longer required by any remaining packs to be potentially freed.\n   *\n   * @example\n   * await MapboxGL.offlineManager.deletePack('packName')\n   *\n   * @param  {String}  name  Name of the offline pack.\n   * @return {void}\n   */\n  async deletePack(name) {\n    if (!name) {\n      return;\n    }\n\n    await this._initialize();\n\n    const offlinePack = this._offlinePacks[name];\n    if (offlinePack) {\n      await MapboxGLOfflineManager.deletePack(name);\n      delete this._offlinePacks[name];\n    }\n  }\n\n  /**\n   * Forces a revalidation of the tiles in the ambient cache and downloads a fresh version of the tiles from the tile server.\n   * This is the recommend method for clearing the cache.\n   * This is the most efficient method because tiles in the ambient cache are re-downloaded to remove outdated data from a device.\n   * It does not erase resources from the ambient cache or delete the database, which can be computationally expensive operations that may carry unintended side effects.\n   *\n   * @example\n   * await MapboxGL.offlineManager.invalidateAmbientCache();\n   *\n   * @return {void}\n   */\n  async invalidateAmbientCache() {\n    await this._initialize();\n    await MapboxGLOfflineManager.invalidateAmbientCache();\n  }\n\n  /**\n   * Erases resources from the ambient cache.\n   * This method clears the cache and decreases the amount of space that map resources take up on the device.\n   *\n   * @example\n   * await MapboxGL.offlineManager.clearAmbientCache();\n   *\n   * @return {void}\n   */\n  async clearAmbientCache() {\n    await this._initialize();\n    await MapboxGLOfflineManager.clearAmbientCache();\n  }\n\n  /**\n   * Sets the maximum size of the ambient cache in bytes. Disables the ambient cache if set to 0.\n   * This method may be computationally expensive because it will erase resources from the ambient cache if its size is decreased.\n   *\n   * @example\n   * await MapboxGL.offlineManager.setMaximumAmbientCacheSize(5000000);\n   *\n   * @param  {Number}  size  Size of ambient cache.\n   * @return {void}\n   */\n  async setMaximumAmbientCacheSize(size) {\n    await this._initialize();\n    await MapboxGLOfflineManager.setMaximumAmbientCacheSize(size);\n  }\n\n  /**\n   * Deletes the existing database, which includes both the ambient cache and offline packs, then reinitializes it.\n   *\n   * @example\n   * await MapboxGL.offlineManager.resetDatabase();\n   *\n   * @return {void}\n   */\n  async resetDatabase() {\n    await this._initialize();\n    await MapboxGLOfflineManager.resetDatabase();\n  }\n\n  /**\n   * Retrieves all the current offline packs that are stored in the database.\n   *\n   * @example\n   * const offlinePacks = await MapboxGL.offlineManager.getPacks();\n   *\n   * @return {Array<OfflinePack>}\n   */\n  async getPacks() {\n    await this._initialize();\n    return Object.keys(this._offlinePacks).map(\n      name => this._offlinePacks[name],\n    );\n  }\n\n  /**\n   * Retrieves an offline pack that is stored in the database by name.\n   *\n   * @example\n   * const offlinePack = await MapboxGL.offlineManager.getPack();\n   *\n   * @param  {String}  name  Name of the offline pack.\n   * @return {OfflinePack}\n   */\n  async getPack(name) {\n    await this._initialize();\n    return this._offlinePacks[name];\n  }\n\n  /**\n   * Sideloads offline db\n   *\n   * @example\n   * await MapboxGL.offlineManager.mergeOfflineRegions(path);\n   *\n   * @param {String} path Path to offline tile db on file system.\n   * @return {void}\n   */\n  async mergeOfflineRegions(path) {\n    await this._initialize();\n    return MapboxGLOfflineManager.mergeOfflineRegions(path);\n  }\n\n  /**\n   * Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.\n   * The Mapbox Terms of Service prohibit changing or bypassing this limit without permission from Mapbox.\n   *\n   * @example\n   * MapboxGL.offlineManager.setTileCountLimit(1000);\n   *\n   * @param {Number} limit Map tile limit count.\n   * @return {void}\n   */\n  setTileCountLimit(limit) {\n    MapboxGLOfflineManager.setTileCountLimit(limit);\n  }\n\n  /**\n   * Sets the period at which download status events will be sent over the React Native bridge.\n   * The default is 500ms.\n   *\n   * @example\n   * MapboxGL.offlineManager.setProgressEventThrottle(500);\n   *\n   * @param {Number} throttleValue event throttle value in ms.\n   * @return {void}\n   */\n  setProgressEventThrottle(throttleValue) {\n    MapboxGLOfflineManager.setProgressEventThrottle(throttleValue);\n  }\n\n  /**\n   * Subscribe to download status/error events for the requested offline pack.\n   * Note that createPack calls this internally if listeners are provided.\n   *\n   * @example\n   * const progressListener = (offlinePack, status) => console.log(offlinePack, status)\n   * const errorListener = (offlinePack, err) => console.log(offlinePack, err)\n   * MapboxGL.offlineManager.subscribe('packName', progressListener, errorListener)\n   *\n   * @param  {String} packName           Name of the offline pack.\n   * @param  {Callback} progressListener Callback that listens for status events while downloading the offline resource.\n   * @param  {Callback} errorListener      Callback that listens for status events while downloading the offline resource.\n   * @return {void}\n   */\n  async subscribe(packName, progressListener, errorListener) {\n    const totalProgressListeners = Object.keys(this._progressListeners).length;\n    if (isFunction(progressListener)) {\n      if (totalProgressListeners === 0) {\n        this.subscriptionProgress = OfflineModuleEventEmitter.addListener(\n          MapboxGL.OfflineCallbackName.Progress,\n          this._onProgress,\n        );\n      }\n      this._progressListeners[packName] = progressListener;\n    }\n\n    const totalErrorListeners = Object.keys(this._errorListeners).length;\n    if (isFunction(errorListener)) {\n      if (totalErrorListeners === 0) {\n        this.subscriptionError = OfflineModuleEventEmitter.addListener(\n          MapboxGL.OfflineCallbackName.Error,\n          this._onError,\n        );\n      }\n      this._errorListeners[packName] = errorListener;\n    }\n\n    // we need to manually set the pack observer on Android\n    // if we're resuming a pack download instead of going thru the create flow\n    if (isAndroid() && this._offlinePacks[packName]) {\n      try {\n        // manually set a listener, since listeners are only set on create flow\n        await MapboxGLOfflineManager.setPackObserver(packName);\n      } catch (e) {\n        console.log('Unable to set pack observer', e);\n      }\n    }\n  }\n\n  /**\n   * Unsubscribes any listeners associated with the offline pack.\n   * It's a good idea to call this on componentWillUnmount.\n   *\n   * @example\n   * MapboxGL.offlineManager.unsubscribe('packName')\n   *\n   * @param  {String} packName Name of the offline pack.\n   * @return {void}\n   */\n  unsubscribe(packName) {\n    delete this._progressListeners[packName];\n    delete this._errorListeners[packName];\n\n    if (\n      Object.keys(this._progressListeners).length === 0 &&\n      this.subscriptionProgress\n    ) {\n      this.subscriptionProgress.remove();\n    }\n\n    if (\n      Object.keys(this._errorListeners).length === 0 &&\n      this.subscriptionError\n    ) {\n      this.subscriptionError.remove();\n    }\n  }\n\n  async _initialize() {\n    if (this._hasInitialized) {\n      return true;\n    }\n\n    const nativeOfflinePacks = await MapboxGLOfflineManager.getPacks();\n\n    for (const nativeOfflinePack of nativeOfflinePacks) {\n      const offlinePack = new OfflinePack(nativeOfflinePack);\n      this._offlinePacks[offlinePack.name] = offlinePack;\n    }\n\n    this._hasInitialized = true;\n    return true;\n  }\n\n  _onProgress(e) {\n    const {name, state} = e.payload;\n\n    if (!this._hasListeners(name, this._progressListeners)) {\n      return;\n    }\n\n    const pack = this._offlinePacks[name];\n    this._progressListeners[name](pack, e.payload);\n\n    // cleanup listeners now that they are no longer needed\n    if (state === MapboxGL.OfflinePackDownloadState.Complete) {\n      this.unsubscribe(name);\n    }\n  }\n\n  _onError(e) {\n    const {name} = e.payload;\n\n    if (!this._hasListeners(name, this._errorListeners)) {\n      return;\n    }\n\n    const pack = this._offlinePacks[name];\n    this._errorListeners[name](pack, e.payload);\n  }\n\n  _hasListeners(name, listenerMap) {\n    return (\n      !isUndefined(this._offlinePacks[name]) && isFunction(listenerMap[name])\n    );\n  }\n}\n\nconst offlineManager = new OfflineManager();\nexport default offlineManager;\n"]},"metadata":{},"sourceType":"module"}